"""
Author: Ben Janis
Date: 2025

This source file is part of an example system for MITRE's 2025 Embedded System CTF
(eCTF). This code is being provided only for educational purposes for the 2025 MITRE
eCTF competition, and may not meet MITRE standards for quality. Use this code at your
own risk!

Copyright: Copyright (c) 2025 The MITRE Corporation
"""

import argparse
import json
from pathlib import Path
import struct

from Cryptodome.Cipher import AES
from Cryptodome.Hash import SHA256
from Cryptodome.Random import get_random_bytes
#from Cryptodome.Util.Padding import pad

from loguru import logger

import secrets as secret_gen
import ast


def gen_subscription(
    secrets: bytes, device_id: int, start: int, end: int, channel: int
) -> bytes:
    """Generate the contents of a subscription.

    The output of this will be passed to the Decoder using ectf25.tv.subscribe

    :param secrets: Contents of the secrets file generated by ectf25_design.gen_secrets
    :param device_id: Device ID of the Decoder
    :param start: First timestamp the subscription is valid for
    :param end: Last timestamp the subscription is valid for
    :param channel: Channel to enable
    """
    # TODO: Update this function to provide a Decoder with whatever data it needs to
    #   subscribe to a new channel

    # Load the json of the secrets file
    secrets = json.loads(secrets)


    #sub_key = secrets[f'channel_{channel}']['subscription_key']

    #sub_info = struct.pack("<IQQI", device_id, start, end, channel)
    sub_info = struct.pack("<IQQ", device_id, start, end)
    #check_sum = secrets[f'channel_{channel}']['check_sum']
    #check_sum = ast.literal_eval(get_channel_key(channel, secrets)['check_sum'])
    check_sum = bytes.fromhex(get_channel_key(channel, secrets)['check_sum'])
    #check_sum_channel = bytes(check_sum, 'utf-8')
    #check_sum_channel = ast.literal_eval(check_sum)

    #print(check_sum_channel)
    # print("sub and check: ", sub_info, check_sum)

    interwoven_bytestring = interweave(sub_info, check_sum)

    # print(interwoven_bytestring)
    
    encrypted_data = encrypt(interwoven_bytestring, secrets, channel)

    channel_num = channel.to_bytes(4, byteorder="little", signed=False)


    '''
    print("interwoven_bytestring length: ", len(interwoven_bytestring))
    print("encrypted_data length: ", len(encrypted_data))
    print("ret length: ", len(ret))
    print("ret: ", ret)
    print("ret + encrypted_data length: ", len(ret + encrypted_data))
    print("ret + encrpted_data: ", ret + encrypted_data)
    '''
    # print(channel_num + encrypted_data)
    # print(len(channel_num + encrypted_data))
    return channel_num + encrypted_data

    

def pad(data, block_size):
        """Pad the data to the block size"""
        assert type(data) == bytes, "Data must be bytes"
        padding_length = block_size - (len(data) % block_size)
        return data + b'\x00' * padding_length

def interweave(sub_info, check_sum_channel):
    if len(sub_info) != len(check_sum_channel) or len(sub_info) != 20:
        #print(len(sub_info), len(check_sum_channel))
        raise ValueError("invalid lengths")
    
    ret = bytearray()

    for i in range(len(sub_info)):
        ret.append(sub_info[i])
        ret.append(check_sum_channel[i])
        

    #print("ret", ret)
    return bytes(ret)
    
def get_channel_key(channel, secrets):
    if channel not in secrets['channels']:
        raise ValueError("Channel not found in secrets")
    return secrets[f'channel_{channel}']

def encrypt(interwoven_bytestring, secrets, channel):

    #print("interwoven_bytestring: ", interwoven_bytestring)

    data = pad(interwoven_bytestring, 16)
    #print("padded length: ", len(data))
    #subscription_key = ast.literal_eval(get_channel_key(channel, secrets)['subscription_key'])
    subscription_key = bytes.fromhex(get_channel_key(channel, secrets)['subscription_key'])
    iv = secret_gen.token_bytes(16)
    # iv = eval("b'\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01'")

    aes = AES.new(subscription_key, AES.MODE_CBC, iv)
    cipher = aes.encrypt(data)

    return cipher + iv
    





def parse_args():
    """Define and parse the command line arguments

    NOTE: Your design must not change this function
    """
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "--force",
        "-f",
        action="store_true",
        help="Force creation of subscription file, overwriting existing file",
    )
    parser.add_argument(
        "secrets_file",
        type=argparse.FileType("rb"),
        help="Path to the secrets file created by ectf25_design.gen_secrets",
    )
    parser.add_argument("subscription_file", type=Path, help="Subscription output")
    parser.add_argument(
        "device_id", type=lambda x: int(x, 0), help="Device ID of the update recipient."
    )
    parser.add_argument(
        "start", type=lambda x: int(x, 0), help="Subscription start timestamp"
    )
    parser.add_argument("end", type=int, help="Subscription end timestamp")
    parser.add_argument("channel", type=int, help="Channel to subscribe to")
    return parser.parse_args()


def main():
    """Main function of gen_subscription

    You will likely not have to change this function
    """
    # Parse the command line arguments
    args = parse_args()

    subscription = gen_subscription(
        args.secrets_file.read(), args.device_id, args.start, args.end, args.channel
    )

    # Print the generated subscription for your own debugging
    # Attackers will NOT have access to the output of this (although they may have
    # subscriptions in certain scenarios), but feel free to remove
    #
    # NOTE: Printing sensitive data is generally not good security practice
    logger.debug(f"Generated subscription: {subscription}")

    # Open the file, erroring if the file exists unless the --force arg is provided
    with open(args.subscription_file, "wb" if args.force else "xb") as f:
        f.write(subscription)

    # For your own debugging. Feel free to remove
    logger.success(f"Wrote subscription to {str(args.subscription_file.absolute())}")


if __name__ == "__main__":
    main()

    # secrets = {'checksum':['abcdblablablaabcdblablab' for i in range(10)]}
    # device_id = 1
    # start = 2
    # end = 6
    # channel = 8
    
    # sub_info = struct.pack("<IQQI", device_id, start, end, channel)
    # check_sum_channel = secrets['checksum'][channel].encode('utf-8')

    # print(type(sub_info))
    # print(sub_info)
    # print(type(check_sum_channel))
    # print(check_sum_channel)
    # print(len(sub_info), len(check_sum_channel))

    # sub_info = bytes(24)
    # check_sum_channel = bytes([0xFF] * 24)
    # interwoven_bytestring = interweave(sub_info, check_sum_channel)

    # print(interwoven_bytestring)

    # print(' '.join(f"{byte:08b}" for byte in sub_info), end='\n\n')
    # print(' '.join(f"{byte:08b}" for byte in check_sum_channel), end='\n\n')
    # print(' '.join(f"{byte:08b}" for byte in interwoven_bytestring), end='\n\n')



    
